import "std.gma"

MSG_SIZE        :: 1024
PORT            :: 6969
MAX_PENDING_CON :: 3

// TODO: multiline string
HTML :: "HTTP/1.1 200 ok\nServer: HTTP Server\nKeep-Alive: timeout=2, max=200\nConnection: Keep-Alive\nContent-type: text/html\n\n<h1>Hello from HTTP Server written in gamma</h1>\n"

I32_SIZE :: 4
SOCKADDR_IN_SIZE :: 16

fn testSwapEndians() {
    printStr("swap endian tests\n")
    printUint(6969) printStr("\n")
    printUint(htons(6969)) printStr("\n")
    printUint(ntohs(htons(6969))) printStr("\n")

    printUint(69696969) printStr("\n")
    printUint(htonl(69696969)) printStr("\n")
    printUint(ntohl(htonl(69696969))) printStr("\n\n")
}

fn main() {
    testSwapEndians()


    // create ipv4/tcp socket --------------------------------------------------------
    fd := socket(AF_INET, SOCK_STREAM, 0)
    if fd == -1 {
        printStr("error: could not create socket file descriptor\n")
        exit(1)
    }
    printStr("created socket file descriptor: ") printInt(fd) printStr("\n")


    // test getsockopt ---------------------------------------------------------------
    opt := 0
    optlen := I32_SIZE
    err := getsockopt(fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, &optlen)
    if err != 0 {
        printInt(err) printStr(" getsockopt error\n")
        exit(1)
    }
    printStr("reuseable port/addr: ") printInt(opt) printStr("\n")


    // make addr and port reusable ---------------------------------------------------
    opt = 1
    err = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, optlen)
    if err != 0 {
        printInt(err) printStr(" setsockopt error\n")
        exit(1)
    }
    printStr("set port/addr as reuseable\n")


    // prepare socket for connections ------------------------------------------------
    addr := sockaddr_in{ sin_family: AF_INET, sin_port: htons(PORT), sin_addr: INADDR_ANY, sin_zero: 0 }

    err = bind(fd, &addr, SOCKADDR_IN_SIZE)
    if err != 0 {
        printInt(err) printStr(" bind error\n")
        exit(1)
    }

    err = listen(fd, MAX_PENDING_CON)
    if err != 0 {
        printInt(err) printStr(" listen error\n")
        exit(1)
    }

    sockaddr_in_size u32 := SOCKADDR_IN_SIZE
    client_fd := accept(fd, &addr, &sockaddr_in_size)
    if client_fd == -1 {
        printInt(client_fd) printStr(" accept error\n")
        exit(1)
    }


    // send and recv http ------------------------------------------------------------
    buffer := [MSG_SIZE]char {}
    readSize := read(client_fd, buffer as *char, MSG_SIZE)

    printChar('\n')
    for i i64, readSize {
        printChar(buffer[i])
    }
    printChar('\n')

    bytes := send(client_fd, HTML, 0)
    if bytes == -1 {
        printInt(bytes) printStr(" send error\n")
        exit(1)
    }


    // shutdown and close sockets ----------------------------------------------------
    err = close(client_fd)
    if err != 0 {
        printInt(err) printStr(" close client_fd error\n")
        exit(1)
    }

    err = shutdown(fd, SHUT_RDWR)
    if err != 0 {
        printInt(err) printStr(" socket shutdown error\n")
        exit(1)
    }
}
