cfn test1() -> i32 {
    ret 30 + 34
}

cfn testIf() -> i32 {
    c :: 2

    if c == 1 {
        ret 30 + 34
    } elif c == 2 {
        ret -(30 + 34)
    } else {
        ret c
    }
}

cfn testSwitch() -> i32 {
    c :: 3

    if c == {
        1: ret 30 + 38 + c
        2: ret -(30 + 37 + c)
        _: ret c * c
    }
}

cfn testThrough() -> i32 {
    c :: 2

    if c == {
        1:
            ret 30 + 38 + c
        2:
            if c > 1 {
                through
            } else {
                ret 420
            }
        _:
            ret c * c
    }
}

cfn testVar() -> i32 {
    i := 1

    i = i + 2

    if i == 1 {
        ret 63 + i
    } else {
        ret -i
    }
}

cfn testArgs(i i32) -> i32 {
    if i == {
        0: ret i - 64
        1: ret i + 63
        2: ret 418 + i
        _: ret i
    }
}

cfn testDeref() -> bool {
    word i16 := 0x0001
    ptr *bool := &word as u64 as *bool
    ret *ptr == false
}

fn isBigEndian() -> bool {
    word i16 := 0x0001
    ptr *bool := &word as u64 as *bool
    ret *ptr == false
}

cfn testFor(a i32) -> i32 {
    res := 0
    for i i32, a {
        res = res + i
    }
    ret res
}

cfn testWhile(a i32) -> i32 {
    while a % 3 != 0 || a % 4 != 0 {
        a = a + 1
    }

    ret a
}

cfn testPtr() -> bool {
    word i16 := 0x0001
    ptr *bool := &word as u64 as *bool
    ptr2 := &ptr
    ret **ptr2 == false
}

cfn testArr() -> [3]i32 {
    res := [3]i32{}

    for i i32, 3 {
        res[i] = 1 + i * 2
    }

    ret res
}

cfn testArr2() -> [3]i32 {
    res := [3]i32{}
    ptr := &res

    for i i32, 3 {
        *ptr[i] = 1 + i * 2
    }

    ret res
}

struct Test {
    b bool,
    i i32
}

cfn testStruct(i i32) -> i32 {
    t := Test{ true, 0 }
    t.i = i
    ret t.i
}

cfn testDeref2(i i32) -> i32 {  // TODO "-> {" wrong error (no missing type error)
    i2 := 0
    ptr := &i2
    *ptr = i
    ret i2
}

fn printArr(arr [3]i32) {
    printStr("{ ")

    printInt(arr[0]) printStr(", ")
    printInt(arr[1]) printStr(", ")
    printInt(arr[2])

    printStr(" }\n")
}

cfn fib(i u64) -> u64 {
    ret $ i == {
        0, 1: 1 as u64
           _: fib(i-1) + fib(i-2)
    }
}

fn main() {
    printStr("\ntest simple --------\n")
    printInt(test1()) printChar('\n')
    printInt(testIf()) printChar('\n')
    printInt(testSwitch()) printChar('\n')
    printInt(testThrough()) printChar('\n')
    printInt(testVar()) printChar('\n')

    printStr("\ntest args --------\n")
    printInt(testArgs(0)) printChar('\n')
    printInt(testArgs(1)) printChar('\n')
    printInt(testArgs(2)) printChar('\n')
    printInt(testArgs(69)) printChar('\n')

    printStr("\ntest deref --------\n")
    printBool(testDeref()) printChar('\n')
    printBool(isBigEndian()) printChar('\n')
    printBool(testPtr()) printChar('\n')

    printStr("\ntest loops --------\n")
    printInt(testFor(6)) printChar('\n')
    printInt(testFor(3)) printChar('\n')
    printInt(testWhile(3)) printChar('\n')
    printInt(testWhile(13)) printChar('\n')

    printStr("\ntest array --------\n")
    printArr(testArr())
    printArr(testArr2())

    printStr("\ntest struct --------\n")
    printInt(testStruct(64)) printChar('\n')
    printInt(testStruct(-64)) printChar('\n')

    printStr("\ntest assign deref --------\n")
    printInt(testDeref2(-64)) printChar('\n')

    printStr("\ntest recursive --------\n")
    printUint(fib(0)) printChar('\n')
    printUint(fib(1)) printChar('\n')
    printUint(fib(2)) printChar('\n')
    printUint(fib(3)) printChar('\n')
    printUint(fib(4)) printChar('\n')
    printUint(fib(5)) printChar('\n')

    printChar('\n')
    for i u64, 6 {
        printUint(fib(i)) printChar('\n')
    }
}
