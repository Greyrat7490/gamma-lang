enum Test {
    A, B, C                 // 0, 1, 2 (u64)
}

enum Test2 u8 {
    A(i64), B(str), C(bool) // 0, 1, 2 (u8)
}

fn test1() {
    println("test1")

    a := Test::A
    b := Test::B
    c := Test::C

    if a : Test::A {
        println("a == Test::A")
    }

    if b : Test::B {
        println("b == Test::B")
    }

    if c : Test::C {
        println("c == Test::C")
    }
}

fn test2() {
    println("test2")

    s := "test string 2"

    a := Test2::A(86)
    b := Test2::B("test string")
    c := Test2::C(true)
    b2 := Test2::B(s)

    if a : Test2::A(a) {
        println(fmt("i64: {}", a))
    }

    if c : Test2::C(c) {
        println(fmt("bool: {}", c))
        c = false                   // no side effect c is a new var
    }

    if c : Test2::C(c) {
        println(fmt("bool: {}", c))
    }

    if b : Test2::B(b) {
        println(fmt("str: {}", b))
    }

    if b2 : Test2::B(b) {
        println(fmt("str: {}", b))
    }

    if b2 : Test2::C(_) {
        println("dead code")
    } else {
        println("b2 is not a Test2::C")
    }

    /*
    if a : Test2::{
        A(a): print(fmt("i64: {}", a))
        B(b): print(fmt("string: {}", b))
        C(c): print(fmt("bool: {}", c))
    }
    */
}

fn test3() {
    println("test3")

    a := Test2::A(420)
    b := &a

    if *b : Test2::A(b) {
        println(fmt("A: {}", b))
    }

    if *b : Test2::C(_) {
        println("dead code")
    } else {
        println("*b is not a Test2::C")
    }
}

enum SmallEnum u32 {
    A(u32), B(bool), C(u8)
}

struct Test3 {
    a u64,
    b u64,
    t Test2
}

fn test4() {
    println("test4")

    t := Test3{ a: 86, b: 69, t: Test2::A(64) }
    
    if t.t : Test2::A(a) {
        println(fmt("A: {}", a))
    }
}

cfn retStruct() -> Test3 {
    // TODO typecheck and resolve EnumLit
    ret Test3{ 1, 2, Test2::A(86) }
}

fn test5() {
    println("test5")

    if retStruct().t : Test2::A(a) {
        println(fmt("A: {}", a))
    }

    if retStruct().t : Test2::B(_) {
        println("dead code")
    } else {
        println("retStruct().t is not a Test2::B")
    }
}

fn test6() {
    a :: retStruct()
    b :: a.t
    if b : Test2::A(a) {
        println(fmt("A: {}", a))
    }
}

cfn test7() -> str {
    b :: Test2::B("test string")
    if b : Test2::A(b) {
        ret "unreachable"
    }

    ret "test string"
}

fn main() {
    test1()
    test2()
    test3()
    test4()
    test5()
    test6()
    println(test7())
}
