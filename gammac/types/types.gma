Int_Kind     u8 :: 1
Uint_Kind    u8 :: 2
Char_Kind    u8 :: 3
Bool_Kind    u8 :: 4
Ptr_Kind     u8 :: 5
Arr_Kind     u8 :: 6
Vec_Kind     u8 :: 7
Str_Kind     u8 :: 8
Struct_Kind  u8 :: 9
Invalid_Kind u8 :: -1 as u8


I8_Size   u8 :: 1
I16_Size  u8 :: 2
I32_Size  u8 :: 4
I64_Size  u8 :: 8

U8_Size   u8 :: 1
U16_Size  u8 :: 2
U32_Size  u8 :: 4
U64_Size  u8 :: 8

Char_Size u8 :: 1
Bool_Size u8 :: 1
Ptr_Size  u8 :: 8
Arr_Size  u8 :: 8
Str_Size  u8 :: Ptr_Size + U32_Size
Vec_Size  u8 :: Ptr_Size + U64_Size + U64_Size


struct Type {
    Type_Kind u8,
    Info u32    // uint/int size or idx to InfoStruct
}

struct PtrType {}
struct ArrType {}
struct VecType {}
struct StructType {}


DEFAULT_TYPES_POOL_SIZE :: 10

struct TypesPool {
    ptrInfo [$]PtrType,
    arrInfo [$]ArrType,
    vecInfo [$]VecType,
    structInfo [$]StructType
}


fn InitTypesPool() -> TypesPool {
    ret TypesPool{ 
        [$]PtrType{ DEFAULT_TYPES_POOL_SIZE  },
        [$]ArrType{ DEFAULT_TYPES_POOL_SIZE  },
        [$]VecType{ DEFAULT_TYPES_POOL_SIZE  },
        [$]StructType{ DEFAULT_TYPES_POOL_SIZE  }
    }
}

fn ToBaseType(s str) -> Type {
    ret $ s == {
    "i8":   Type{ Int_Kind, 1 }
    "i16":  Type{ Int_Kind, 2 }
    "i32":  Type{ Int_Kind, 4 }
    "i64":  Type{ Int_Kind, 8 }
    "u8":   Type{ Uint_Kind, 1 }
    "u16":  Type{ Uint_Kind, 2 }
    "u32":  Type{ Uint_Kind, 4 }
    "u64":  Type{ Uint_Kind, 8 }
    "char": Type{ Char_Kind, 0 }
    "bool": Type{ Bool_Kind, 0 }
    "str":  Type{ Str_Kind, 0 }
    _:      Type{ Invalid_Kind, 0 }
    }
}
